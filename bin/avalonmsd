#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Avalon Music Server
#
# Copyright 2012-2013 TSH Labs <projects@tshlabs.org>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


"""
AvalonMS: Scan a music collection for metadata and expose it as an HTTP
service using JSON.
"""

from __future__ import print_function

import argparse
import os
import re
import signal
import sys

import cherrypy

import avalon.app.factory
import avalon.cli
import avalon.exc


APP_PATH = '/avalon'


def get_parser(prog, defaults):
    """Parse required and optional program arguments."""
    parser = argparse.ArgumentParser(prog=prog, description=__doc__)

    parser.add_argument(
        'collection',
        action=avalon.cli.CollectionAction,
        help='Path to the root of your music collection')
    parser.add_argument(
        '--access-log',
        metavar='PATH',
        help='Log all requests to the server to this file '
             '(requests are logged to STDOUT by default)')
    parser.add_argument(
        '--daemon',
        action='store_true',
        help='Run the server in the background as a daemon')
    parser.add_argument(
        '--daemon-user',
        action=avalon.cli.DaemonUserAction,
        metavar='USER',
        help='Switch to this user when running as a daemon')
    parser.add_argument(
        '--daemon-group',
        action=avalon.cli.DaemonGroupAction,
        metavar='GROUP',
        help='Switch to this group when running as a daemon')
    parser.add_argument(
        '--db-path',
        metavar='PATH',
        help='File to use for backing SQLite database '
             '(default is %s)' % defaults.db_path)
    parser.add_argument(
        '--error-log',
        metavar='PATH',
        help='Log any errors or informational messages to this file '
             '(errors are logged to STDERR by default)')
    parser.add_argument(
        '--no-scan',
        action='store_true',
        help='Do not rescan and rebuild the music collection database '
             'at start up or during any reloads (graceful events)')
    parser.add_argument(
        '--server-address',
        action=avalon.cli.IpAddressAction,
        metavar='ADDR',
        help='IP Address to bind to (default is %s)' % defaults.server_address)
    parser.add_argument(
        '--server-port',
        action=avalon.cli.ServerPortAction,
        metavar='PORT',
        help='Port for server to listen  on '
             '(default is %s)' % defaults.server_port)
    parser.add_argument(
        '--server-queue',
        action=avalon.cli.ServerQueueAction,
        metavar='NUM',
        help='Number of connections to allow to be queued '
             '(default is %s)' % defaults.server_queue)
    parser.add_argument(
        '--server-threads',
        action=avalon.cli.ServerThreadsAction,
        metavar='NUM',
        help='Number of threads to use for handling requests '
             '(default is %s)' % defaults.server_threads)

    return parser


def setup_signal_handler():
    """Set up a basic signal handler to deal with ^C quietly
    until the server starts up (which will install its own
    handlers).
    """

    def _exit_handler(signum, frame):
        """Handle TERM and INT by exiting."""
        if signum in (signal.SIGTERM, signal.SIGINT):
            raise SystemExit()

    signal.signal(signal.SIGINT, _exit_handler)
    signal.signal(signal.SIGTERM, _exit_handler)


def setup_cherrypy_env():
    """Disable printing of stack traces for errors and make
    sure that we disable default logging.
    """
    cherrypy.config.update({'environment': 'production'})
    cherrypy.log.access_file = None
    cherrypy.log.error_file = None
    cherrypy.log.screen = False


def main():
    """Parse and validate user input and start the application."""
    prog = re.sub('[^\w]+', '', os.path.basename(sys.argv[0]))
    defaults = avalon.cli.ServerAppDefaults()
    config = avalon.cli.ServerAppConfig(get_parser(prog, defaults), defaults)

    setup_signal_handler()
    setup_cherrypy_env()

    try:
        config.validate()
    except ValueError, e:
        print('%s: %s' % (prog, str(e)), file=sys.stderr)
        return 1

    try:
        log = avalon.app.factory.new_logger(config, cherrypy.log)
        db = avalon.app.factory.new_db_engine(config, log)
        db.connect()
    except (avalon.exc.DatabaseError, avalon.exc.PermissionError), e:
        # NOTE: permission errors are caught here instead of attempting
        # to check for them during configuration validation since that
        # is susceptible to race conditions.
        print('%s: %s' % (prog, str(e)), file=sys.stderr)
        return 1

    dao = avalon.app.factory.new_dao(db)
    controller = avalon.app.factory.new_controller(dao)
    server = avalon.app.factory.new_server(config, log, controller, APP_PATH)
    bus = cherrypy.process.wspbus.Bus()

    engine = avalon.app.factory.new_plugin_engine(
        config, log, db, server, bus)

    log.info("Starting server...")
    engine.start()
    log.info("Server stopped")
    return 0


if __name__ == '__main__':
    sys.exit(main())

