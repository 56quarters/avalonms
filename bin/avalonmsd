#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Avalon Music Server
#
# Copyright 2012-2014 TSH Labs <projects@tshlabs.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#


"""
AvalonMS: Scan a music collection for metadata and expose it as an HTTP
service using JSON.
"""

from __future__ import print_function

import argparse
import os
import re
import signal
import sys

import cherrypy

import avalon.app.factory
import avalon.cli
import avalon.exc


APP_PATH = '/avalon'


def get_parser(prog, defaults):
    """Parse required and optional program arguments."""
    parser = argparse.ArgumentParser(prog=prog, description=__doc__)

    parser.add_argument(
        'collection',
        action=avalon.cli.CollectionAction,
        help='Path to the root of your music collection')
    parser.add_argument(
        '--access-log',
        metavar='PATH',
        help='Log all requests to the server to this file '
             '(requests are logged to STDOUT by default)')
    parser.add_argument(
        '--daemon',
        action='store_true',
        help='Run the server in the background as a daemon')
    parser.add_argument(
        '--daemon-user',
        action=avalon.cli.DaemonUserAction,
        metavar='USER',
        help='Switch to this user when running as a daemon')
    parser.add_argument(
        '--daemon-group',
        action=avalon.cli.DaemonGroupAction,
        metavar='GROUP',
        help='Switch to this group when running as a daemon')
    parser.add_argument(
        '--db-path',
        metavar='PATH',
        help='File to use for backing SQLite database '
             '(default is %s)' % defaults.db_path)
    parser.add_argument(
        '--error-log',
        metavar='PATH',
        help='Log any errors or informational messages to this file '
             '(errors are logged to STDERR by default)')
    parser.add_argument(
        '--no-scan',
        action='store_true',
        help='Do not rescan and rebuild the music collection database '
             'at start up or during any reloads (graceful events)')
    parser.add_argument(
        '--server-address',
        action=avalon.cli.IpAddressAction,
        metavar='ADDR',
        help='IP Address to bind to (default is %s)' % defaults.server_address)
    parser.add_argument(
        '--server-port',
        action=avalon.cli.ServerPortAction,
        metavar='PORT',
        help='Port for server to listen  on '
             '(default is %s)' % defaults.server_port)
    parser.add_argument(
        '--server-queue',
        action=avalon.cli.ServerQueueAction,
        metavar='NUM',
        help='Number of connections to allow to be queued '
             '(default is %s)' % defaults.server_queue)
    parser.add_argument(
        '--server-threads',
        action=avalon.cli.ServerThreadsAction,
        metavar='NUM',
        help='Number of threads to use for handling requests '
             '(default is %s)' % defaults.server_threads)

    return parser


def setup_signal_handler():
    """Set up a basic signal handler to deal with ^C quietly
    until the server starts up (which will install its own
    handlers).
    """

    def _exit_handler(signum, frame):
        """Handle TERM and INT by exiting."""
        if signum in (signal.SIGTERM, signal.SIGINT):
            raise SystemExit()

    signal.signal(signal.SIGINT, _exit_handler)
    signal.signal(signal.SIGTERM, _exit_handler)


def setup_cherrypy_env():
    """Disable printing of stack traces for errors and make
    sure that we disable default logging.
    """
    cherrypy.config.update({'environment': 'production'})
    cherrypy.log.access_file = None
    cherrypy.log.error_file = None
    cherrypy.log.screen = False


def main():
    """Parse and validate user input and start the application."""
    prog = re.sub('[^\w]+', '', os.path.basename(sys.argv[0]))
    defaults = avalon.cli.ServerAppDefaults()
    config = avalon.cli.ServerAppConfig(get_parser(prog, defaults), defaults)

    setup_signal_handler()
    setup_cherrypy_env()

    try:
        config.validate()
    except ValueError, e:
        print('%s: %s' % (prog, str(e)), file=sys.stderr)
        return 1

    try:
        log = avalon.app.factory.new_logger(config, cherrypy.log)
        db = avalon.app.factory.new_db_engine(config, log)
        db.connect()
    except (avalon.exc.DatabaseError, avalon.exc.PermissionError), e:
        # NOTE: permission errors are caught here instead of attempting
        # to check for them during configuration validation since that
        # is susceptible to race conditions.
        print('%s: %s' % (prog, str(e)), file=sys.stderr)
        return 1

    dao = avalon.app.factory.new_dao(db)
    controller = avalon.app.factory.new_controller(dao)
    server = avalon.app.factory.new_server(config, log, controller, APP_PATH)
    bus = cherrypy.process.wspbus.Bus()

    engine = avalon.app.factory.new_plugin_engine(
        config, log, db, server, bus)

    log.info("Starting server...")
    engine.start()
    log.info("Server stopped")
    return 0


if __name__ == '__main__':
    sys.exit(main())

